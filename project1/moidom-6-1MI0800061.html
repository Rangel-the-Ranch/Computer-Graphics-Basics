<!DOCTYPE html>

<!-- Рангел Плачков, група 6, 1MI0800061 -->

<html>
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="three.min.js"></script>
		<script src="OrbitControls.js"></script>
	</head>
	
	<body>
		<script>
			const FN = '1MI0800061';
		</script>
		
		<script src="init.js"></script>
		<script src="CSG.js"></script>
			
		<script>

			let house = new THREE.Group();

			class Wall{
				static wallWight = 0.2;
				static wallHeight = 3;
				static groundBuffer = 0.01;
				static wallPosY = Wall.wallHeight/2 - Wall.groundBuffer;
				
				

				static defaultColor = "yellow";
				static defaultShininess = 10;

				static defaultDoorLen = 1;
				static defaultDoorHeight = 2;
				static defaultDoorFrameColor = "grey";
				static defaultDoorFrameWight = Wall.wallWight + 0.05;
				static defaultDoorFrameBuff = 0.1;

				static defaultFrameColor = "white";
				static defaultGlassColor = "blue";
				static defaultWindowsHeight = 1.5;
				static defaultWindowFrameWight = Wall.wallWight + 0.05;
				static defaultWindowFrameBuff = 0.1;
				static defaultFrameThicknes = 0.1;
				static defaultGlassOpacity = 0.4;

				static wallCount = 0;
				static wallsArr = [];
				static windowsArr = [];
				static windowCount = 0;
				static doorCount = 0;
				static doorArr = [];
				
				constructor(lenght, isXwall, posX, posZ){
					this.color = Wall.defaultColor;
					this.posX = posX;
					this.posY = Wall.wallPosY;
					this.posZ = posZ;
					this.lenghtY = Wall.wallHeight;
					
					if(isXwall){
						this.lenghtX =  lenght;
						this.lenghtZ = Wall.wallWight;
						
					}else{
						this.lenghtX = Wall.wallWight;
						this.lenghtZ = lenght;
					}
					this.geometry = new THREE.BoxGeometry( this.lenghtX, this.lenghtY, this.lenghtZ );
					this.material = new THREE.MeshPhongMaterial( {color: this.color, shininess: Wall.defaultShininess} );
					
					this.reRender();
				}
				reRender(){
					this.render = new THREE.Mesh( this.geometry, this.material );
					this.render.position.set( this.posX, this.posY, this.posZ );
				}
				shadows(recive,cast){
					this.render.receiveShadow = recive;
					this.render.castShadow = cast;
				}

				generateWall(){
					this.shadows(1,1);
					house.add(this.render);
				}
				addWindow(windowLen){
					const isXwall = (this.lenghtX > this.lenghtZ);
					let hole;
					if(isXwall){
						hole = new THREE.Mesh( new THREE.BoxGeometry( windowLen, Wall.defaultWindowsHeight, this.lenghtZ ));
					}else{
						hole = new THREE.Mesh( new THREE.BoxGeometry( this.lenghtX, Wall.defaultWindowsHeight, windowLen ));
					
					}
					
					const csg = new CSG();
					const tempRend = new THREE.Mesh( this.geometry )
					csg.subtract( [tempRend, hole] );

					this.render = csg.toMesh();
					this.render.material = this.material;
					this.render.position.set( this.posX, this.posY, this.posZ );

					this.addWindowFrame(windowLen,isXwall);

				}
				addWindowFrame(windowLen,isXwall){
					let window = new THREE.Group();
					const frameMaterial = new THREE.MeshPhongMaterial( {color: Wall.defaultFrameColor, shininess: Wall.defaultShininess} );
					const glassMaterial = new THREE.MeshPhysicalMaterial( {color:Wall.defaultGlassColor, transparent: true, opacity: Wall.defaultGlassOpacity} );
					let frameGeometryHor,frameGeometryVer,glassGeometry;
					if(isXwall){
						frameGeometryHor = new THREE.BoxGeometry( windowLen, Wall.defaultWindowFrameBuff, Wall.defaultWindowFrameWight );
						frameGeometryVer  = new THREE.BoxGeometry( Wall.defaultWindowFrameBuff, Wall.defaultWindowsHeight+Wall.defaultWindowFrameBuff, Wall.defaultWindowFrameWight);
						glassGeometry = new THREE.BoxGeometry( windowLen, Wall.defaultWindowsHeight, Wall.defaultFrameThicknes);
					}else{
						frameGeometryHor = new THREE.BoxGeometry(  Wall.defaultWindowFrameWight, Wall.defaultWindowFrameBuff, windowLen );
						frameGeometryVer  = new THREE.BoxGeometry( Wall.defaultWindowFrameWight, Wall.defaultWindowsHeight+Wall.defaultWindowFrameBuff, Wall.defaultWindowFrameBuff);
						glassGeometry = new THREE.BoxGeometry( Wall.defaultFrameThicknes, Wall.defaultWindowsHeight, windowLen );
					}
					const windowFrameTop = new THREE.Mesh(frameGeometryHor, frameMaterial);
					windowFrameTop.position.set(this.posX, this.posY+Wall.defaultWindowsHeight/2, this.posZ);					
					const windowFrameBot = new THREE.Mesh(frameGeometryHor, frameMaterial);
					windowFrameBot.position.set(this.posX, this.posY-Wall.defaultWindowsHeight/2, this.posZ);

					const windowFrameLeft = new THREE.Mesh(frameGeometryVer, frameMaterial);
					const windowFrameRight = new THREE.Mesh(frameGeometryVer, frameMaterial);
					const glass = new THREE.Mesh(glassGeometry, glassMaterial);
					if(isXwall){
						windowFrameLeft.position.set(this.posX+windowLen/2, this.posY, this.posZ);
						windowFrameRight.position.set(this.posX-windowLen/2, this.posY, this.posZ);
					}else{
						windowFrameLeft.position.set(this.posX, this.posY, this.posZ+windowLen/2);
						windowFrameRight.position.set(this.posX, this.posY, this.posZ-windowLen/2);
					}
					glass.position.set(this.posX, this.posY, this.posZ);
					window.add(windowFrameTop);
					window.add(windowFrameBot);
					window.add(windowFrameLeft);
					window.add(windowFrameRight);
					window.add(glass);
					/*
					windowFrameTop.castShadow = true;
					windowFrameBot.castShadow = true;
					windowFrameLeft.castShadow = true;
					windowFrameRight.castShadow = true;
					windowFrameTop.receiveShadow = true;
					windowFrameBot.receiveShadow = true;
					windowFrameLeft.receiveShadow = true;
					windowFrameRight.receiveShadow = true;
					*/
					glass.castShadow = false;
					glass.receiveShadow = false;
					Wall.windowsArr[Wall.windowCount] = window;
					Wall.windowCount++;
					
				}

				static generateWindows(){
					for(let i = 0; i<Wall.windowCount; i++){
						house.add(Wall.windowsArr[i]);
					}
				}

				addDoor(){
					
					const isXwall = (this.lenghtX > this.lenghtZ);
					let hole;
					if(isXwall){
						hole = new THREE.Mesh( new THREE.BoxGeometry( Wall.defaultDoorLen, Wall.defaultDoorHeight, this.lenghtZ ));
					}else{
						hole = new THREE.Mesh( new THREE.BoxGeometry( this.lenghtX, Wall.defaultDoorHeight, Wall.defaultDoorLen ));
					
					}
					hole.position.set(0,this.posY-(Wall.defaultDoorHeight/2)+Wall.groundBuffer ,0);
					const csg = new CSG();
					const tempRend = new THREE.Mesh( this.geometry )
					csg.subtract( [tempRend, hole] );

					this.render = csg.toMesh();
					this.render.rotation.x += Math.PI 
					this.render.material = this.material;
					this.render.position.set( this.posX, this.posY, this.posZ );

					this.addDoorFrame(isXwall);
				}
				addDoorFrame(isXwall){
					let door = new THREE.Group();
					const frameMaterial = new THREE.MeshPhongMaterial( {color: Wall.defaultDoorFrameColor, shininess: Wall.defaultShininess} );
					let frameGeometryHor, frameGeometryVer;
					if(isXwall){
						frameGeometryHor = new THREE.BoxGeometry( Wall.defaultDoorLen, Wall.defaultDoorFrameBuff, Wall.defaultDoorFrameWight );
						frameGeometryVer  = new THREE.BoxGeometry( Wall.defaultDoorFrameBuff, Wall.defaultDoorHeight+Wall.defaultDoorFrameBuff, Wall.defaultDoorFrameWight);
					}else{
						frameGeometryHor = new THREE.BoxGeometry(  Wall.defaultDoorFrameWight, Wall.defaultDoorFrameBuff, Wall.defaultDoorLen );
						frameGeometryVer  = new THREE.BoxGeometry( Wall.defaultDoorFrameWight, Wall.defaultDoorHeight+Wall.defaultDoorFrameBuff, Wall.defaultDoorFrameBuff);
					}
					const doorFrameTop = new THREE.Mesh(frameGeometryHor, frameMaterial);
					const doorFrameLeft = new THREE.Mesh(frameGeometryVer, frameMaterial);
					const doorFrameRight = new THREE.Mesh(frameGeometryVer, frameMaterial);
					doorFrameTop.position.set(this.posX,this.posY+(Wall.wallHeight - Wall.defaultDoorHeight)/2,this.posZ);
					if(isXwall){
						doorFrameLeft.position.set(this.posX - Wall.defaultDoorLen/2,this.posY- (Wall.wallHeight - Wall.defaultDoorHeight)/2,this.posZ);
						doorFrameRight.position.set(this.posX + Wall.defaultDoorLen/2,this.posY- (Wall.wallHeight - Wall.defaultDoorHeight)/2,this.posZ);
					}else{
						doorFrameLeft.position.set(this.posX,this.posY- (Wall.wallHeight - Wall.defaultDoorHeight)/2,this.posZ-Wall.defaultDoorLen/2);
						doorFrameRight.position.set(this.posX,this.posY- (Wall.wallHeight - Wall.defaultDoorHeight)/2,this.posZ+Wall.defaultDoorLen/2);
					}


					door.add(doorFrameRight);
					door.add(doorFrameTop);
					door.add(doorFrameLeft);
					/*
					doorFrameRight.castShadow = true;
					doorFrameTop.castShadow = true;
					doorFrameLeft.castShadow = true;
					doorFrameRight.receiveShadow = true;
					doorFrameTop.receiveShadow = true;
					doorFrameLeft.receiveShadow = true;
					*/
					Wall.doorArr[Wall.doorCount] = door;
					
					Wall.doorCount++;
					
				}
				static generateDoors(){
					for(let i = 0; i<Wall.doorCount; i++){
						house.add(Wall.doorArr[i]);
					}
				}
				paint(color){
					this.color = color;
					this.material = new THREE.MeshPhongMaterial( {color: this.color, shininess: Wall.defaultShininess} );
					reRender();
				}
				rotate(angle){
					this.render.rotation.y += angle;
				}
				static newXWall(lenght,posX, posY){
					Wall.wallsArr[Wall.wallCount] = new Wall (lenght, 1, posX, posY);
					Wall.wallCount++;
				}
				static newZWall(lenght, posX, posY){
					Wall.wallsArr[Wall.wallCount] = new Wall (lenght, 0, posX, posY);
					Wall.wallCount++;
				}
				
				static generateAllWalls(){
					for(let i=0; i<Wall.wallCount; i++){
						Wall.wallsArr[i].generateWall();
					}
				}
				static generateAll(){
					Wall.generateAllWalls();
					Wall.generateDoors();
					Wall.generateWindows();
				}
			}
			class Floor{
				static defaultXsize = 1;
				static defaultZsize = 1;
				static FloorArr = [];
				static FloorCount = 0;

				constructor(posX,posZ,lenX,lenZ,color){
					this.lenghtX = lenX;
					this.lenghtZ = lenZ;
					this.posX = posX;
					this.posZ = posZ;
					this.color = color;
				}
				generate(){
					const geometry = new THREE.PlaneGeometry( this.lenghtX, this.lenghtZ);
					const material = new THREE.MeshPhongMaterial( {color: this.color, shininess: 0} );
					const render = new THREE.Mesh(geometry,material);
					render.position.set(this.posX,0,this.posZ);
					render.rotation.x -= Math.PI/2;
					render.receiveShadow = true;
					render.castShadow = true;
					house.add(render);
				}
				static generateAll(){
					for(let i=0; i<Floor.FloorCount; i++){
						Floor.FloorArr[i].generate();
					}
				}
				static newFloor(posX, posZ,lenX,lenZ,color){
					Floor.FloorArr[Floor.FloorCount] = new Floor (posX, posZ,lenX,lenZ,color);
					Floor.FloorCount++;
				}
			}
			class Furniture{
				static All = new THREE.Group();
				static furnitureCount = 0;

				static addTable(posX,posZ, color){
					
					let table = new THREE.Group();

					const legHeight = 0.7;
					const legBaseheihgt = 0.05;

					const tableMaterial = new THREE.MeshPhongMaterial( {color: color} );
					const shape = new THREE.Shape();
					shape.moveTo(   1 ,0.5 );
					shape.lineTo(   1.2 ,0.3 );
					shape.lineTo(   1.2 ,-0.3 );
					shape.lineTo(   1, -0.5);
					shape.lineTo(  -1, -0.5);
					shape.lineTo(   -1.2 ,-0.3 );
					shape.lineTo(   -1.2 ,0.3 );
					shape.lineTo(  -1, 0.5 );
					shape.lineTo(   1 ,0.5 );
					const baseGeometry = new THREE.CylinderGeometry( 0.1, 0.1, legBaseheihgt, 32 );
					const base1=new THREE.Mesh( baseGeometry, tableMaterial);
					base1.position.set(0.9 , legBaseheihgt/2 , 0.3);
					const base2=new THREE.Mesh( baseGeometry, tableMaterial);
					base2.position.set(0.9 , legBaseheihgt/2 , -0.3);
					const base3=new THREE.Mesh( baseGeometry, tableMaterial);
					base3.position.set(-0.9 , legBaseheihgt/2 , 0.3);
					const base4=new THREE.Mesh( baseGeometry, tableMaterial);
					base4.position.set(-0.9 , legBaseheihgt/2 , -0.3);

					const extrudeSettings = { depth: 0.09, bevelEnabled: false};
					const mainGeometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
					const main = new THREE.Mesh( mainGeometry, tableMaterial);
					main.position.set(0,legHeight+0.1,0);
					main.rotation.x+=Math.PI/2;
					const legGeometry = new THREE.CylinderGeometry( 0.1, 0.05, legHeight, 32 );
					const leg1 = new THREE.Mesh( legGeometry, tableMaterial);
					leg1.position.set(0.9,legHeight/2 + legBaseheihgt,0.3);
					const leg2 = new THREE.Mesh( legGeometry, tableMaterial);
					leg2.position.set(-0.9,legHeight/2 + legBaseheihgt,0.3);
					const leg3 = new THREE.Mesh( legGeometry, tableMaterial);
					leg3.position.set(-0.9,legHeight/2 + legBaseheihgt,-0.3);
					const leg4 = new THREE.Mesh( legGeometry, tableMaterial);
					leg4.position.set(0.9,legHeight/2 + legBaseheihgt,-0.3);

					base1.castShadow = true;
					base2.castShadow = true;
					base3.castShadow = true;
					base4.castShadow = true;
					leg1.castShadow = true;
					leg2.castShadow = true;
					leg3.castShadow = true;
					leg4.castShadow = true;
					main.castShadow = true;
					base1.receiveShadow = true;
					base2.receiveShadow = true;
					base3.receiveShadow = true;
					base4.receiveShadow = true;
					leg1.receiveShadow = true;
					leg2.receiveShadow = true;
					leg3.receiveShadow = true;
					leg4.receiveShadow = true;
					main.receiveShadow = true;
					table.add(leg1,leg2,leg3,leg4);
					table.add(base1,base2,base3,base4);
					table.add(main);
					table.position.set(posX,0,posZ);
					table.rotation.y += Math.PI/2;
					table.receiveShadow = true;
					table.castShadow = true;
					Furniture.All.add(table);
					Furniture.FloorCount++;
				}
				static addAshtray(posX,posY,posZ){
					// S05 E02
					const scaleDown = 1/20;
					const body = new THREE.Mesh( new THREE.CylinderGeometry( 2*scaleDown, 2.5*scaleDown, 1*scaleDown, 8 ) );
					const hole = new THREE.Mesh( new THREE.CylinderGeometry( 1.7*scaleDown, 1.7*scaleDown, 1*scaleDown, 8 ));
					hole.position.set( 0, 0.3*scaleDown, 0 );
			
					const gutter1 = new THREE.Mesh( new THREE.CylinderGeometry( 0.3*scaleDown, 0.3*scaleDown, 5*scaleDown, 40 ));
						gutter1.position.y = 0.5*scaleDown;
						gutter1.rotation.x = Math.PI/2;
						gutter1.rotation.z = 3*Math.PI/8;
			
					const gutter2 = new THREE.Mesh( new THREE.CylinderGeometry( 0.3*scaleDown, 0.3*scaleDown, 5*scaleDown, 40 ));
						gutter2.position.y = 0.5*scaleDown;
						gutter2.rotation.x = Math.PI/2;
						gutter2.rotation.z = 7*Math.PI/8;

					var csg = new CSG();
					csg.subtract( [body, hole, gutter1, gutter2] );
					const ashTray = csg.toMesh();
					ashTray.material = new THREE.MeshPhongMaterial( {
						color: "grey"});

					ashTray.castShadow = true;
					ashTray.receiveShadow = true;
					ashTray.position.set(posX,posY,posZ);

					Furniture.All.add(ashTray);
					Furniture.FloorCount++;			
				}
				static addBow(posX,posY,posZ,color){
					const scaleDown = 1/15;
					const body = new THREE.Mesh( new THREE.CylinderGeometry( 2.5*scaleDown, 2*scaleDown, 1*scaleDown, 32 ) );
					const hole = new THREE.Mesh( new THREE.CylinderGeometry( 2.4*scaleDown, 1.9*scaleDown, 1*scaleDown, 23 ));
					hole.position.set( 0, 0.3*scaleDown, 0 );
					var csg = new CSG();
					csg.subtract( [body, hole] );
					const dogBow = csg.toMesh();
					dogBow.material = new THREE.MeshPhongMaterial( {
						color: color});
						dogBow.castShadow = false;
						dogBow.receiveShadow = false;
						dogBow.position.set(posX,posY,posZ);

					Furniture.All.add(dogBow);
					Furniture.FloorCount++;	
				}
				static addHammock(posX,posZ,rot){
					//Задача на аситента 5
					const body = new THREE.Group();
					const hammockLenght = 2 ,hammockLenghtInner = 1.9, segments = 16;
					const boxOne = new THREE.Mesh( new THREE.BoxGeometry( hammockLenght, hammockLenght/2, hammockLenght/2 ) );
					boxOne.position.set(0,-hammockLenght/4,-hammockLenght/4);
					const csg = new CSG();
					csg.intersect( [new THREE.Mesh( new THREE.SphereGeometry( hammockLenght/2, segments, segments) ), boxOne] );
					const csgTwo = new CSG();
					csgTwo.subtract( [csg.toMesh(), new THREE.Mesh( new THREE.SphereGeometry( hammockLenghtInner/2, segments, segments) )] );
					const hammock = csgTwo.toMesh();
					hammock.material = new THREE.MeshPhongMaterial( { color: 'orange'});
					hammock.rotation.x += -Math.PI/4;

					const polesRadius = 0.1, polesHeight = 2, distanceFromHammock = 0.2, polesPushDown = 0.3;
					const pole1 = new THREE.Mesh(new THREE.CylinderGeometry(polesRadius, polesRadius, polesHeight), new THREE.MeshPhongMaterial({color: 'brown'}));
					pole1.position.set((-1)*(hammockLenght/2 + distanceFromHammock), -polesPushDown, 0);
					const pole2 = new THREE.Mesh(new THREE.CylinderGeometry(polesRadius, polesRadius, polesHeight), new THREE.MeshPhongMaterial({color: 'brown'}));
					pole2.position.set(hammockLenght/2 + distanceFromHammock, -polesPushDown, 0);

					const ropeRadius = 0.02, ropeHeight = 0.3, ropeBuffer = 0.02;
					const rope1 = new THREE.Mesh(new THREE.CylinderGeometry(ropeRadius, ropeRadius, ropeHeight), new THREE.MeshPhongMaterial({color: 'black'}));
					rope1.rotation.z += Math.PI/4;
					rope1.position.set( -hammockLenght/2-ropeBuffer,0,0);
					const rope2 = new THREE.Mesh(new THREE.CylinderGeometry(ropeRadius, ropeRadius, ropeHeight), new THREE.MeshPhongMaterial({color: 'black'}));
					rope2.rotation.z += -Math.PI/4;
					rope2.position.set( hammockLenght/2+ropeBuffer,0,0);

					hammock.castShadow = true;
					pole1.castShadow = true;
					pole2.castShadow = true;
					rope1.castShadow = true;
					rope2.castShadow = true;
					hammock.receiveShadow = true;
					pole1.receiveShadow = true;
					pole2.receiveShadow = true;
					rope1.receiveShadow = true;
					rope2.receiveShadow = true;

					body.add(hammock,pole1,pole2 , rope1 , rope2);
					body.position.set(posX,1,posZ);
					body.rotation.y += rot;


					Furniture.All.add(body);
					Furniture.FloorCount++;	
				}
				static addStatue(posX,posZ,rot){
					//Задача на асистента 6
					const body = new THREE.Group();
					var baseWight = 0.6;
					var baseHeight = 0.5;
					var base = new THREE.Mesh( new THREE.BoxGeometry( baseWight, baseHeight, baseWight ), new THREE.MeshPhongMaterial( {color: "grey", side: THREE.DoubleSide} ) );
					base.position.set(0,-1.75,0);
					body.add(base);

					var base = new THREE.Mesh( new THREE.BoxGeometry( 0.15, 2, 0.15 ), new THREE.MeshPhongMaterial( {color: "grey"} ) );
					base.position.set(-0.1,-0.4,0.3);
					base.rotation.z += 0.1;
					body.add(base);
					base.castShadow = true;
					base.receiveShadow = true;
			
					var base = new THREE.Mesh( new THREE.BoxGeometry( 0.15, 2, 0.15 ), new THREE.MeshPhongMaterial( {color: "grey"} ) );
					base.position.set(0.1,-0.4,0.3);
					base.rotation.z -= 0.1;
					body.add(base);
					base.castShadow = true;
					base.receiveShadow = true;

					var geometry = new THREE.CylinderGeometry( 0.4, 0.3, 2, 32 );
					var material = new THREE.MeshPhongMaterial( {color:"grey"} );
					var cylinder = new THREE.Mesh( geometry, material );
					cylinder.position.set(0,-0.4,0);
					body.add( cylinder );
					cylinder.castShadow = true;
					cylinder.receiveShadow = true;
			
					var geometry = new THREE.CylinderGeometry( 0.2, 0.3,1.7, 32 );
					var material = new THREE.MeshPhongMaterial( {color: "grey"} );
					var cylinder = new THREE.Mesh( geometry, material );
					cylinder.position.set(-0.4,0.6,0);
					cylinder.rotation.z += Math.PI/8;
					cylinder.castShadow = true;
					cylinder.receiveShadow = true;
					body.add( cylinder );

					var geometry = new THREE.CylinderGeometry( 0.07, 0.07 ,0.5, 32 );
					var material = new THREE.MeshPhongMaterial( {color: "black"} );
					var cylinder = new THREE.Mesh( geometry, material );
					cylinder.rotation.z += Math.PI/9;
					cylinder.position.set(-0.7,1.5,0);
					cylinder.castShadow = true;
					cylinder.receiveShadow = true;
					body.add( cylinder );
					var geometry = new THREE.CylinderGeometry( 0.07, 0.07 ,0.5, 32 );
					var material = new THREE.MeshPhongMaterial( {color: "black"} );
					var cylinder = new THREE.Mesh( geometry, material );
					cylinder.rotation.z -= Math.PI/9;
					cylinder.position.set(0.7,1.5,0);
					cylinder.castShadow = true;
					cylinder.receiveShadow = true;
					body.add( cylinder );

					var geometry = new THREE.CylinderGeometry( 0.25, 0.25 ,0.2, 32 );
					var material = new THREE.MeshPhongMaterial( {color: "black"} );
					var cylinder = new THREE.Mesh( geometry, material );
					cylinder.position.set(0,-1.5,0);
					cylinder.castShadow = true;
					cylinder.receiveShadow = true;
					body.add( cylinder );

					body.add( cylinder );
					var geometry = new THREE.CylinderGeometry( 0.15, 0.15 ,0.5, 32 );
					var material = new THREE.MeshPhongMaterial( {color: "black"} );
					var cylinder = new THREE.Mesh( geometry, material );
					cylinder.rotation.x += 0.2;
					cylinder.position.set(0,0.8,0.1);
					cylinder.castShadow = true;
					cylinder.receiveShadow = true;
					body.add( cylinder );

					var geometry = new THREE.CylinderGeometry( 0.2, 0.3,1.7, 32 );
					var material = new THREE.MeshPhongMaterial( {color: "grey"} );
					var cylinder = new THREE.Mesh( geometry, material );
					cylinder.position.set(0.4,0.6,0);
					cylinder.rotation.z -= Math.PI/8;
					cylinder.castShadow = true;
					cylinder.receiveShadow = true;
					body.add( cylinder );
					body.rotation.y+=rot;
					body.position.set(posX,1.7,posZ);
					
					Furniture.All.add(body);
					Furniture.FloorCount++;	

				}
				static addGlassCup(posX,posY,posZ,color,height){

					let glassCup = new THREE.Group();
					const deScale = 1/20;
					const glassBot = 1, thicknes = 0.3;
					const glassHeight = height;
					const glassMaterial = new THREE.MeshPhysicalMaterial( {color:color, transparent: true, opacity: 0.4} );
					const glassMaterial2 = new THREE.MeshPhysicalMaterial( {color:color, transparent: true, opacity: 0.5} );
					const outer =  new THREE.Mesh(new THREE.CylinderGeometry( glassBot*deScale, glassBot*deScale, glassHeight*deScale, 8 ) );
					const inner = new THREE.Mesh( new THREE.CylinderGeometry( (glassBot-0.1)*deScale, (glassBot-0.1)*deScale, glassHeight*deScale, 80 ) );
					const bot =  new THREE.Mesh(new THREE.CylinderGeometry( (glassBot+0.01)*deScale, (glassBot+0.01)*deScale, thicknes*deScale, 8 ), glassMaterial2 );
					bot.position.set(0,(-glassHeight/2+thicknes/2+0.0001)*(deScale) ,0);
					const csg = new CSG();
					csg.subtract( [outer, inner] );
					const Main = csg.toMesh();
					Main.material =glassMaterial;

					glassCup.add(Main,bot);
					glassCup.position.set(posX,posY+glassBot*deScale,posZ)

					Furniture.All.add(glassCup);
					Furniture.FloorCount++;		

				}
				static kitchenBase(){
					let all = new THREE.Group();
					const baseMaterial = new THREE.MeshPhongMaterial( {color:"#663300"} );
					const baseGeometry = new THREE.BoxGeometry(0.5,0.15,4.3);
					
					const base = new THREE.Mesh(baseGeometry,baseMaterial);
					base.receiveShadow = true;
					const baseGeometry2 = new THREE.BoxGeometry(0.85,1,0.7);
					const base2 = new THREE.Mesh(baseGeometry2,baseMaterial);
					base.position.set(0,0,-0.5)
					base2.position.set(-0.18,0.55,-2.25);
					base2.receiveShadow = true;
					base2.castShadow = true;
					all.add(base,base2);
					const baseGeometry3 = new THREE.BoxGeometry(2,0.15,0.5);
					const base3 = new THREE.Mesh(baseGeometry3,baseMaterial);
					base3.position.set(-1.2,0,-2.3);
					all.add(base3);
					
					
					all.position.set(6.6,0.07,0.8);
					Furniture.All.add(all);
					Furniture.FloorCount++;


				}
				static addTopDrawer(posX,posY,posZ,leftDrawer,color,rot){
					let all = new THREE.Group();
					const doorBuffer = 0.02;
					const baseMaterial = new THREE.MeshPhongMaterial( {color:color} );
					const baseGeometry = new THREE.BoxGeometry(0.4,1,0.8);
					const base = new THREE.Mesh(baseGeometry,baseMaterial);
					all.add(base);
					base.castShadow = true;
					base.receiveShadow = true;
					const doorGeometry = new THREE.BoxGeometry(0.05,1-doorBuffer,0.8-doorBuffer);
					const door = new THREE.Mesh(doorGeometry,baseMaterial);
					door.position.set(0.23,0,0);
					all.add(door);
					//door.castShadow = true;
					//door.receiveShadow = true;
					const handleMat = new THREE.MeshPhongMaterial( {color:"silver"} );
					const handle1geom = new THREE.TorusGeometry(0.1,0.01,7,32,Math.PI);
					const handle1 = new THREE.Mesh(handle1geom,handleMat);
					handle1.rotation.z -= Math.PI/2;
					if(leftDrawer){
						handle1.position.set(0.2,-0.3,0.3);
					}else{
						handle1.position.set(0.2,-0.3,-0.3);
					}
					handle1.castShadow = true;
					handle1.receiveShadow = true;
					all.add(handle1);

					all.position.set(posX,posY,posZ);
					all.rotation.y += rot;
					Furniture.All.add(all);
					Furniture.FloorCount++;
				}
				static addBotDrawer(posX,posY,posZ,leftDrawer,color,rot){
					let all = new THREE.Group();
					const doorBuffer = 0.02;
					const baseMaterial = new THREE.MeshPhongMaterial( {color:color} );
					const baseGeometry = new THREE.BoxGeometry(0.4,1,0.8);
					const base = new THREE.Mesh(baseGeometry,baseMaterial);
					all.add(base);
					base.castShadow = true;
					base.receiveShadow = true;
					const doorGeometry = new THREE.BoxGeometry(0.05,1-doorBuffer,0.8-doorBuffer);
					const door = new THREE.Mesh(doorGeometry,baseMaterial);
					door.position.set(0.23,0,0);
					all.add(door);
					//door.castShadow = true;
					//door.receiveShadow = true;
					const handleMat = new THREE.MeshPhongMaterial( {color:"silver"} );
					const handle1geom = new THREE.TorusGeometry(0.1,0.01,7,32,Math.PI);
					const handle1 = new THREE.Mesh(handle1geom,handleMat);
					handle1.rotation.z -= Math.PI/2;
					if(leftDrawer){
						handle1.position.set(0.2,+0.3,0.3);
					}else{
						handle1.position.set(0.2,+0.3,-0.3);
					}
					//handle1.castShadow = true;
					//handle1.receiveShadow = true;
					all.add(handle1);

					all.position.set(posX,posY,posZ);
					all.rotation.y += rot;
					Furniture.All.add(all);
					Furniture.FloorCount++;
				}
				static addDrawer2(posX,posY,posZ,leftDrawer,color,rot){
					let all = new THREE.Group();
					const doorBuffer = 0.01;
					const baseMaterial = new THREE.MeshPhongMaterial( {color:color} );
					const baseGeometry = new THREE.BoxGeometry(0.4,1,0.6);
					const base = new THREE.Mesh(baseGeometry,baseMaterial);
					const doorGeometry = new THREE.BoxGeometry(0.05,0.2-doorBuffer,0.6-doorBuffer);
					const door1 = new THREE.Mesh(doorGeometry,baseMaterial);
					door1.position.set(0.23,0.4,0);
					const door2 = new THREE.Mesh(doorGeometry,baseMaterial);
					door2.position.set(0.23,0.2,0);
					const door3 = new THREE.Mesh(doorGeometry,baseMaterial);
					door3.position.set(0.23,0,0);
					const doorGeometry2 = new THREE.BoxGeometry(0.05,0.4-doorBuffer,0.6-doorBuffer);
					const door4 = new THREE.Mesh(doorGeometry2,baseMaterial);
					door4.position.set(0.23,-0.3,0);
					base.castShadow = true;
					base.receiveShadow = true;
					all.add(base,door1,door2,door3,door4);
					const handleMat = new THREE.MeshPhongMaterial( {color:"silver"} );
					const handle1geom = new THREE.TorusGeometry(0.1,0.01,7,32,Math.PI);
					const handle1 = new THREE.Mesh(handle1geom,handleMat);
					handle1.rotation.x -= Math.PI/2;
					handle1.rotation.z -= Math.PI/2;
					handle1.position.set(0.2,0.4,0);
					const handle2 = new THREE.Mesh(handle1geom,handleMat);
					handle2.rotation.x -= Math.PI/2;
					handle2.rotation.z -= Math.PI/2;
					handle2.position.set(0.2,0.2,0);
					const handle3 = new THREE.Mesh(handle1geom,handleMat);
					handle3.rotation.x -= Math.PI/2;
					handle3.rotation.z -= Math.PI/2;
					handle3.position.set(0.2,0,0);
					const handle4 = new THREE.Mesh(handle1geom,handleMat);
					handle4.rotation.z -= Math.PI/2;
					if(leftDrawer){
						handle4.position.set(0.2,-0.3,0.2);
					}else{
						handle4.position.set(0.2,-0.3,-0.2);
					}

					all.add(handle1,handle2,handle3,handle4);	
					all.position.set(posX,posY,posZ);
					all.rotation.y += rot;
					Furniture.All.add(all);
					Furniture.FloorCount++;
					
				}
				static addKitchenSink(posX,posY,posZ,color){
					let all = new THREE.Group();
					const deScale = 1/2;
					const sinkMaterial = new THREE.MeshPhongMaterial( {color: "silver", shininess: 40,specular: 'white'} )
					const outer =  new THREE.Mesh(new THREE.BoxGeometry( 2*deScale,0.5*deScale,1*deScale ));
					outer.position.set(-0.1,0,0);
					const inner = new THREE.Mesh( new THREE.CylinderGeometry( 0.5*deScale,0.35*deScale,0.8*deScale,20));
					const inner2 = new THREE.Mesh( new THREE.CylinderGeometry(  0.5*deScale,0.35*deScale,0.8*deScale,20));
					const inner3 = new THREE.Mesh( new THREE.BoxGeometry( 0.75*deScale,0.1*deScale,0.8*deScale));
					inner.position.set(0.2*deScale,0.2*deScale,0*deScale);
					inner2.position.set(-0*deScale,0.2*deScale,0*deScale);
					inner3.position.set(-0.7*deScale,0.2*deScale,0*deScale);
					const csg = new CSG();
					csg.subtract( [outer, inner,inner2,inner3] );
					const Main = csg.toMesh();
					Main.receiveShadow = true;
					Main.material = sinkMaterial;
					const DrawerMaterial = new THREE.MeshPhongMaterial( {color:color} )
					const DrawerGeometry = new THREE.BoxGeometry(1.6,0.7,0.6);
					const Drawer = new THREE.Mesh(DrawerGeometry,DrawerMaterial);
					const wallOf1g = new THREE.BoxGeometry(1.6,0.7,0.05);
					const wallOf1= new THREE.Mesh(wallOf1g,DrawerMaterial);
					const wallOf2g = new THREE.BoxGeometry(1.6,0.7,0.1);
					const wallOf2= new THREE.Mesh(wallOf1g,DrawerMaterial);
					const wallOf3g = new THREE.BoxGeometry(0.5,0.7,0.55);
					const wallOf3= new THREE.Mesh(wallOf3g,DrawerMaterial);
					const wallOf4g = new THREE.BoxGeometry(0.1,0.7,0.55);
					const wallOf4= new THREE.Mesh(wallOf4g,DrawerMaterial);
					const sink1g = new THREE.BoxGeometry(0.05,0.25,0.05);
					const sink1= new THREE.Mesh(sink1g,sinkMaterial);
					const sink2g = new THREE.BoxGeometry(0.2,0.05,0.05);
					const sink2= new THREE.Mesh(sink2g,sinkMaterial);
					Main.position.set(0,0.02,0);
					Drawer.position.set(-0.3,-0.5,0);
					Drawer.castShadow = true;
					
					wallOf1.position.set(-0.3,-0.2,0.28);
					wallOf2.position.set(-0.3,-0.2,-0.25);
					wallOf3.position.set(-0.85,-0.2,-0);
					wallOf4.position.set(0.45,-0.2,-0);
					sink1.position.set(0.35,0.2,-0);
					sink2.position.set(0.25,0.30,-0);
					all.add(Drawer,wallOf1,wallOf2,wallOf3,wallOf4);
					all.add(sink1,sink2);
					const doorBuffer = 0.02;
					const doorGeometry = new THREE.BoxGeometry(0.05,1-doorBuffer,0.8-doorBuffer);
					const door = new THREE.Mesh(doorGeometry,DrawerMaterial);
					door.position.set(0.1,-0.35,0.33);
					door.rotation.y += Math.PI/2;
					all.add(door);
					const door2 = new THREE.Mesh(doorGeometry,DrawerMaterial);
					door2.position.set(-0.7,-0.35,0.33);
					door2.rotation.y += Math.PI/2;
					all.add(door2);
					const handleMat = new THREE.MeshPhongMaterial( {color:"silver"} );
					const handle1geom = new THREE.TorusGeometry(0.1,0.01,7,32,Math.PI);
					const handle1 = new THREE.Mesh(handle1geom,handleMat);
					handle1.position.set(-0.2,0,0.34);
					handle1.rotation.z -= Math.PI/2;
					handle1.rotation.y -= Math.PI/2;
					const handle2 = new THREE.Mesh(handle1geom,handleMat);
					handle2.position.set(-0.4,0,0.34);
					handle2.rotation.z -= Math.PI/2;
					handle2.rotation.y -= Math.PI/2;
					door.receiveShadow = true;
					door2.receiveShadow = true;

					all.add(Main,handle1,handle2);

					all.position.set(posX,posY,posZ);
					//all.rotation.y += Math.PI;
					Furniture.All.add(all);
					Furniture.FloorCount++;

				}
				static generateAll(){
					house.add(Furniture.All);
				}
				static addChair(posX,posZ,color,rot){
					let all = new THREE.Group();
					const deScale = 0.7;
					const legLen = 0.5;
					const material = new THREE.MeshPhongMaterial( {color: color} )
					const base =  new THREE.Mesh(new THREE.CylinderGeometry( 0.3*deScale,0.3*deScale,0.1*deScale ,32 ),material);
					const baseInner = new THREE.Mesh(new THREE.CylinderGeometry( 0.2*deScale,0.2*deScale,0.1*deScale ,32 ),material);
					const base2 = new THREE.Mesh(new THREE.BoxGeometry( 0.6*deScale,0.1*deScale,0.5*deScale ),material);
					const base2Inner = new THREE.Mesh(new THREE.BoxGeometry( 0.55*deScale,0.1*deScale,0.5*deScale ),material);
					const base3 = new THREE.Mesh(new THREE.BoxGeometry( 0.65*deScale,0.7*deScale,0.1*deScale ),material);
					const legGeom = new THREE.CylinderGeometry( 0.05*deScale,0.05*deScale,legLen*deScale );
					const legMat = new THREE.MeshPhongMaterial( {color: "silver"} );;
					const leg1 =  new THREE.Mesh(legGeom,legMat);
					leg1.rotation.x += Math.PI/2
					leg1.position.set(-0.25*deScale,0*deScale,-0.82*deScale);
					const leg2 =  new THREE.Mesh(legGeom,legMat);
					leg2.rotation.x += Math.PI/2
					leg2.position.set(0.25*deScale,0*deScale,-0.82*deScale);
					const leg3 =  new THREE.Mesh(legGeom,legMat);
					leg3.rotation.x += Math.PI/2
					leg3.position.set(0.25*deScale,-0.6*deScale,-0.82*deScale);
					const leg4 =  new THREE.Mesh(legGeom,legMat);
					leg4.rotation.x += Math.PI/2
					leg4.position.set(-0.25*deScale,-0.6*deScale,-0.82*deScale);
					base2.position.set(0*deScale,0*deScale,-0.3*deScale);
					base3.position.set(0*deScale,-0.3*deScale,-0.6*deScale);
					baseInner.position.set(0*deScale,0.1*deScale,0*deScale);
					base2Inner.position.set(0*deScale,0.1*deScale,-0.3*deScale);
					base3.castShadow = true;
					base3.receiveShadow = true;
					base2.castShadow = true;
					base2.receiveShadow = true;
					all.add(base,base2,base3,baseInner,base2Inner,leg1,leg2,leg3,leg4);
					all.rotation.x -= Math.PI/2;
					
					all.position.set(posX,0.7,posZ);
					all.rotation.z += rot;
					scene.add(all);
				}
				
			}

			Wall.newZWall(6, 6.90 , 1);	
			//Wall.wallsArr[Wall.wallCount-1].addWindow(4);	
			Wall.newXWall(2.2, 5.9 ,3.9);
			Wall.newZWall(4, 4.90 , 6);
			Wall.newXWall(4, -1 ,7.9);
			Wall.wallsArr[Wall.wallCount-1].addDoor();
			Wall.newXWall(4, 3 ,7.9);
			Wall.newZWall(4, -2.9 ,5.8);
			Wall.newXWall(4, -5 ,3.9);
			Wall.wallsArr[Wall.wallCount-1].addWindow(2);
			Wall.newZWall(6, -6.9 ,1);
			Wall.wallsArr[Wall.wallCount-1].addWindow(2);
			Wall.newXWall(4, -5 ,-1.9);	
			Wall.wallsArr[Wall.wallCount-1].addWindow(2);
			Wall.newZWall(4.2, -2.9 ,-3.9);
			Wall.newXWall(8, 1 ,-5.9);	
			Wall.wallsArr[Wall.wallCount-1].addWindow(4);
			Wall.newZWall(4, 4.90 , -4);
			Wall.newXWall(2.2, 5.9 ,-1.9);
			//Wall.wallsArr[Wall.wallCount-1].addWindow(1);
			Wall.newXWall(3.8, 2.9 ,-1.9);
			Wall.newXWall(3.8, -0.9 ,-1.9);
			Wall.wallsArr[Wall.wallCount-1].addDoor();
			Wall.newXWall(2.6, -1.5 ,3.9);
			Wall.wallsArr[Wall.wallCount-1].addDoor();
			Wall.newZWall(4, 2 , 0	);
			Wall.wallsArr[Wall.wallCount-1].addDoor();
			Wall.newZWall(2, 2 , 3	);
			Wall.newZWall(4, 2 , 6	);
			Wall.wallsArr[Wall.wallCount-1].addDoor();
			Wall.newXWall(2.2, 3.1 , 2);
			Wall.newXWall(2.08, 4.51 , 2.9);
			Wall.wallsArr[Wall.wallCount-1].rotate(-1.2);
			Wall.newXWall(2.5, 0.8 , 3.90);
			//Wall.generateAllWalls();
			Wall.generateAll();
			
			Floor.newFloor(-2.5,1,9,6,"brown");
			Floor.newFloor(1,-4,8,4,"brown");
			Floor.newFloor(4.5,0,5,4,"brown");
			Floor.newFloor(6,3,2,2,"brown");
			Floor.newFloor(-0.5,6,5,4,"brown");
			Floor.newFloor(3.5,6,3,4,"grey");
			Floor.newFloor(3.5,3,3,2,"grey");
			Floor.generateAll();

			
			Furniture.addTable(-0.5,1,"#663300");
			Furniture.addAshtray(-0.5,0.82,0.8);
			Furniture.addHammock(-7,10,Math.PI/5);
			
			Furniture.kitchenBase();
			Furniture.addKitchenSink(5.5,0.97,-1.52,"#663300");
			Furniture.addBow(5.5,1,-1.5,"lightblue");
			Furniture.addBow(5.13,1.2,-1.5,"white");
			Furniture.addBow(5.13,1.1,-1.5,"white");
			Furniture.addBow(5.13,1.15,-1.5,"grey");
			Furniture.addGlassCup(4.7,1.15,-1.6,"grey",3);
			Furniture.addGlassCup(4.6,1.15,-1.4,"grey",3);
			Furniture.addGlassCup(4.5,1.15,-1.5,"blue",3);
			Furniture.addGlassCup(4.8,1.15,-1.4,"white",3);
			Furniture.addGlassCup(4.85,1.15,-1.7,"white",3);
			
			Furniture.addStatue(8,-8,-Math.PI/4);
			Furniture.addBow(-0.3,0.82,0.4,"white");
			Furniture.addBow(-0.3,0.82,1.5,"grey");
			Furniture.addBow(-0.6,0.82,1.2,"white");
			
			Furniture.addGlassCup(-0.3,0.82,0,"blue",3);
			Furniture.addGlassCup(-0.7,0.82,0.3,"red",3);
			Furniture.addGlassCup(-0.8,0.81,1.4,"blue",2.4);
			Furniture.addGlassCup(-0.9,0.85,1.2,"grey",4);


			Furniture.addDrawer2(6.6,0.6,-0.2,true,"#663300",Math.PI);
			Furniture.addDrawer2(6.6,0.6,-0.8,false,"#663300",Math.PI);
			
			Furniture.addBotDrawer(6.6,0.6,0.5,false,"#663300",Math.PI);
			Furniture.addBotDrawer(6.6,0.6,1.3,true,"#663300",Math.PI);
			Furniture.addBotDrawer(6.6,0.6,2.1,false,"#663300",Math.PI);
			
			Furniture.addTopDrawer(6.6,2.5,-0.7,false,"#663300",Math.PI);
			Furniture.addTopDrawer(6.6,2.5,0.1,true,"#663300",Math.PI);
			Furniture.addTopDrawer(6.6,2.5,0.9,false,"#663300",Math.PI);
			Furniture.addTopDrawer(6.6,2.5,1.7,true,"#663300",Math.PI);
			Furniture.addChair(-1.3,1.4,"lightgreen",Math.PI/2);
			Furniture.addChair(-1.3,0.4,"lightgreen",Math.PI/2);
			Furniture.addChair(0.3,0.4,"lightgreen",-Math.PI/2.5);
			Furniture.addChair(0.5,1.7,"lightgreen",-Math.PI/1.5);
			
			

			Furniture.generateAll();

			
			scene.add(house);

		</script>
		
	</body>
</html>


