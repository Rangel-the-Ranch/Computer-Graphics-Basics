<!DOCTYPE html>

<!-- Рангел Плачков, група 6, 1MI0800061 -->

<html>
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="three.min.js"></script>
		<script src="OrbitControls.js"></script>
	</head>
	
	<body>
		<script>
			const FN = '1MI0800061';
		</script>
		
		<script src="init.js"></script>
		<script src="CSG.js"></script>
			
		<script>

			let house = new THREE.Group();

			class Wall{
				static wallWight = 0.2;
				static wallHeight = 3;
				static wallPosY = Wall.wallHeight/2 - 0.01;
				

				static defaultColor = "yellow";
				static defaultShininess = 10;
				static defaultDoorLen = 1;
				static defaultDoorHeight = 2;
				
				static defaultFrameColor = "white";
				static defaultGlassColor = "blue";
				static defaultWindowsHeight = 1.5;
				static defaultWindowFrameWight = Wall.wallWight + 0.05;
				static defaultWindowFrameBuff = 0.1;
				static defaultFrameThicknes = 0.1;
				static defaultGlassOpacity = 0.4;

				static wallCount = 0;
				static wallsArr = [];
				static windowsArr = [];
				static windowCount = 0;
				
				constructor(lenght, isXwall, posX, posZ){
					this.color = Wall.defaultColor;
					this.posX = posX;
					this.posY = Wall.wallPosY;
					this.posZ = posZ;
					this.lenghtY = Wall.wallHeight;
					
					if(isXwall){
						this.lenghtX =  lenght;
						this.lenghtZ = Wall.wallWight;
						
					}else{
						this.lenghtX = Wall.wallWight;
						this.lenghtZ = lenght;
					}
					this.geometry = new THREE.BoxGeometry( this.lenghtX, this.lenghtY, this.lenghtZ );
					this.material = new THREE.MeshPhongMaterial( {color: this.color, shininess: Wall.defaultShininess} );
					
					this.reRender();
				}
				reRender(){
					this.render = new THREE.Mesh( this.geometry, this.material );
					this.render.position.set( this.posX, this.posY, this.posZ );
				}
				shadows(recive,cast){
					this.render.receiveShadow = recive;
					this.render.castShadow = cast;
				}

				generateWall(){
					this.shadows(1,1);
					house.add(this.render);
				}
				addWindow(windowLen){
					const isXwall = (this.lenghtX > this.lenghtZ);
					let hole;
					if(isXwall){
						hole = new THREE.Mesh( new THREE.BoxGeometry( windowLen, Wall.defaultWindowsHeight, this.lenghtZ ));
					}else{
						hole = new THREE.Mesh( new THREE.BoxGeometry( this.lenghtX, Wall.defaultWindowsHeight, windowLen ));
					
					}
					
					const csg = new CSG();
					const tempRend = new THREE.Mesh( this.geometry )
					csg.subtract( [tempRend, hole] );

					this.render = csg.toMesh();
					this.render.material = this.material;
					this.render.position.set( this.posX, this.posY, this.posZ );

					this.addWindowFrame(windowLen,isXwall);

				}
				addWindowFrame(windowLen,isXwall){
					let window = new THREE.Group();
					const frameMaterial = new THREE.MeshPhongMaterial( {color: Wall.defaultFrameColor, shininess: Wall.defaultShininess} );
					const glassMaterial = new THREE.MeshPhysicalMaterial( {color:Wall.defaultGlassColor, transparent: true, opacity: Wall.defaultGlassOpacity} );
					let frameGeometryHor,frameGeometryVer,glassGeometry;
					if(isXwall){
						frameGeometryHor = new THREE.BoxGeometry( windowLen, Wall.defaultWindowFrameBuff, Wall.defaultWindowFrameWight );
						frameGeometryVer  = new THREE.BoxGeometry( Wall.defaultWindowFrameBuff, Wall.defaultWindowsHeight+Wall.defaultWindowFrameBuff, Wall.defaultWindowFrameWight);
						glassGeometry = new THREE.BoxGeometry( windowLen, Wall.defaultWindowsHeight, Wall.defaultFrameThicknes);
					}else{
						frameGeometryHor = new THREE.BoxGeometry(  Wall.defaultWindowFrameWight, Wall.defaultWindowFrameBuff, windowLen );
						frameGeometryVer  = new THREE.BoxGeometry( Wall.defaultWindowFrameWight, Wall.defaultWindowsHeight+Wall.defaultWindowFrameBuff, Wall.defaultWindowFrameBuff);
						glassGeometry = new THREE.BoxGeometry( Wall.defaultFrameThicknes, Wall.defaultWindowsHeight, windowLen );
					}
					const windowFrameTop = new THREE.Mesh(frameGeometryHor, frameMaterial);
					windowFrameTop.position.set(this.posX, this.posY+Wall.defaultWindowsHeight/2, this.posZ);					
					const windowFrameBot = new THREE.Mesh(frameGeometryHor, frameMaterial);
					windowFrameBot.position.set(this.posX, this.posY-Wall.defaultWindowsHeight/2, this.posZ);

					const windowFrameLeft = new THREE.Mesh(frameGeometryVer, frameMaterial);
					const windowFrameRight = new THREE.Mesh(frameGeometryVer, frameMaterial);
					const glass = new THREE.Mesh(glassGeometry, glassMaterial);
					if(isXwall){
						windowFrameLeft.position.set(this.posX+windowLen/2, this.posY, this.posZ);
						windowFrameRight.position.set(this.posX-windowLen/2, this.posY, this.posZ);
					}else{
						windowFrameLeft.position.set(this.posX, this.posY, this.posZ+windowLen/2);
						windowFrameRight.position.set(this.posX, this.posY, this.posZ-windowLen/2);
					}
					glass.position.set(this.posX, this.posY, this.posZ);
					window.add(windowFrameTop);
					window.add(windowFrameBot);
					window.add(windowFrameLeft);
					window.add(windowFrameRight);
					window.add(glass);
					

					Wall.windowsArr[Wall.windowCount] = window;
					Wall.windowCount++;
					window.receiveShadow = true;
					window.castShadow = true;
				}

				static generateWindows(){
					for(let i = 0; i<Wall.windowCount; i++){
						house.add(Wall.windowsArr[i]);
					}
				}

				addDoor(){
					
					const isXwall = (this.lenghtX > this.lenghtZ);
					let hole;
					if(isXwall){
						hole = new THREE.Mesh( new THREE.BoxGeometry( Wall.defaultDoorLen, Wall.defaultDoorHeight, this.lenghtZ ));
					}else{
						hole = new THREE.Mesh( new THREE.BoxGeometry( this.lenghtX, Wall.defaultDoorHeight, Wall.defaultDoorLen ));
					
					}
					hole.position.set(0,this.posY-Wall.defaultDoorHeight,0);
					const csg = new CSG();
					const tempRend = new THREE.Mesh( this.geometry )
					csg.subtract( [tempRend, hole] );

					this.render = csg.toMesh();
					this.render.material = this.material;
					this.render.position.set( this.posX, this.posY, this.posZ );
				}
				paint(color){
					this.color = color;
					this.material = new THREE.MeshPhongMaterial( {color: this.color, shininess: Wall.defaultShininess} );
					reRender();
				}
				rotate(angle){
					this.render.rotation.y += angle;
				}
				static newXWall(lenght,posX, posY){
					Wall.wallsArr[Wall.wallCount] = new Wall (lenght, 1, posX, posY);
					Wall.wallCount++;
				}
				static newZWall(lenght, posX, posY){
					Wall.wallsArr[Wall.wallCount] = new Wall (lenght, 0, posX, posY);
					Wall.wallCount++;
				}
				
				static generateAllWalls(){
					for(let i=0; i<Wall.wallCount; i++){
						Wall.wallsArr[i].generateWall();
					}
				}


			}
			
			Wall.defaultColor = "yellow";
			Wall.newZWall(6, 6.90 , 1);		
			Wall.newXWall(2.2, 5.9 ,3.9);
			Wall.newZWall(4, 4.90 , 6);
			Wall.newXWall(4, -1 ,7.9);
			Wall.wallsArr[Wall.wallCount-1].addDoor();
			Wall.newXWall(4, 3 ,7.9);
			Wall.newZWall(4, -2.9 ,5.8);
			Wall.newXWall(4, -5 ,3.9);
			Wall.wallsArr[Wall.wallCount-1].addWindow(2);
			Wall.newZWall(6, -6.9 ,1);
			Wall.wallsArr[Wall.wallCount-1].addWindow(2);
			Wall.newXWall(4, -5 ,-1.9);	
			Wall.wallsArr[Wall.wallCount-1].addWindow(2);
			Wall.newZWall(4.2, -2.9 ,-3.9);
			Wall.newXWall(8, 1 ,-5.9);	
			Wall.wallsArr[Wall.wallCount-1].addWindow(4);
			Wall.newZWall(4, 4.90 , -4);
			Wall.newXWall(2.2, 5.9 ,-1.9);
			Wall.wallsArr[Wall.wallCount-1].addWindow(1);
			Wall.newXWall(3.8, 2.9 ,-1.9);
			Wall.newXWall(3.8, -0.9 ,-1.9);
			Wall.wallsArr[Wall.wallCount-1].addDoor();
			Wall.newXWall(2.6, -1.5 ,3.9);
			Wall.wallsArr[Wall.wallCount-1].addDoor();
			Wall.newZWall(4, 2 , 0	);
			Wall.wallsArr[Wall.wallCount-1].addDoor();
			Wall.newZWall(2, 2 , 3	);
			Wall.newZWall(4, 2 , 6	);
			Wall.wallsArr[Wall.wallCount-1].addDoor();
			Wall.newXWall(2.2, 3.1 , 2);
			Wall.newXWall(2.08, 4.51 , 2.9);
			Wall.wallsArr[Wall.wallCount-1].rotate(-1.2);
			Wall.newXWall(2.5, 0.8 , 3.90	);

			Wall.generateAllWalls();
			Wall.generateWindows();

			scene.add(house);

			
			
		</script>
		
	</body>
</html>


